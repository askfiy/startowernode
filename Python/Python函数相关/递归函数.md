# 递归函数

## 递归的特性

递归（recursion）是一种函数的调用方式，简而言之就是自己调用自己。

递归可以将一个大规模的问题分解成更小的相同问题，经过持续分解到最后问题规模小到可以用非常简单直接的方式来解决，或者将一个问题拆分成不同的各个部分，达到分而解决分而治之的目的。

一个递归函数必须要满足3要素：

1. 必须有一个基本结束条件
2. 必须能改变问题规模
3. 必须调用自身

如下所示，这就是一个标准的递归函数：

```
def function(count):
    if count:
        print(count)
        function(count=count - 1)
    return

function(5)

# 5
# 4
# 3
# 2
# 1
```



# 回溯与递推

函数递归必然经历2个阶段，一个是回溯阶段，一个是递推阶段：

- 回溯：函数不断递归调用自身时的阶段被称为回溯阶段
- 递推：当函数退出递归调用时的阶段被称为递推阶段

下面是一个问姓名的问题，可以非常直白的阐述回溯和递推的2个概念。

首先，你问A多少岁，A会回答你他比B大10岁，然后你又问B多少岁，B会回答你它比C大10岁...

这样直至E，E说他的年龄是18岁，最后问A多少岁？

![image-20210518184616223](https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210518184616223.png)

如上图所示，当你问A年龄的时候，回溯阶段开始。

而当你得知E的年龄后，递推阶段开始，根据E反推出A年龄的过程即递推的过程。

代码表现形式如下：

```
def getAge(n):
    if n == 1:
        return 18
    return getAge(n - 1) + 10


a = getAge(5)
print(a)

# 58
```



# 实例练习

## 数据项提取

有1个不知道维度的列表，现在要将它转换为1维列表，并且按照升序进行排序：

```
oldList = [10, 1.2, [3, 345, 2.2, [15, [88.6, [78, [89.3, 99, [50]]]]]]]
newList = []


def listSort(li):
    for i in li:
        if isinstance(i, list):
            listSort(i)
        else:
            newList.append(i)
    newList.sort()


listSort(oldList)

print(newList)

# [1.2, 2.2, 3, 10, 15, 50, 78, 88.6, 89.3, 99, 345]
```





## 爬楼梯问题

有1个n阶的楼梯，每次可以爬1个台阶或者2个台阶，求解有多少种方法爬完整个楼梯。

```
def climbTheStairs(n):
    if n == 1:
        return 1  # ❶
    if n == 2:
        return 2  # ❷
    return climbTheStairs(n - 1) + climbTheStairs(n - 2)  # ❸

print(climbTheStairs(3))

# 3
```

❶：只有1个台阶，就只有1种走法，一次走1步

❷：只有2个台阶，就只有2中走法，一次走1步或者一次走2步

❸：将1次走1步的算出来，将1次走2步的算出来进行相加

# 递归与while

递归与while循环有一些类似之处，比如都要设置结束条件，但是两者不可一概而论。

如果一个问题规模不被确定，使用递归是最好的方案。

而如果一个问题的规模已被确定，则可以使用while循环进行解决。

但是递归要比while循环的效率更加的低下，因为递归的过程中会进行函数的调用，而函数调用则必定会对内存造成更大的压力，这来源于系统调用栈的栈帧会跟随每一次递归而不断的生成。

# 递归的深度

系统调用栈栈帧的生成不能毫无限制，所以Python对递归的深度进行了最大1000层的限定。

你可以随时修改这个层次，但是如果问题规模过大导致递归层次过多，则可能发生爆内存的情况，因为每一次的栈帧都会保存在内存中，以下是修改递归最大深度限制的方法：

```
>>> import sys
>>> sys.setrecursionlimit(100000)  # ❶
>>> sys.getrecursionlimit()  # ❷
100000
```

❶：修改最大默认递归层次为10000层

❷：获取当前最大的递归层次

# 尾递归优化

递归函数中，每一次的栈帧生成都是相同的。

每一个递归函数的栈帧都拥有相同的调用方（自身）、拥有相同的字节码（相同的函数）、用于相同的命名空间（标识符）。

由于栈帧在系统调用栈中会占用大量的内存，对于某些语言如Java而言，会针对递归函数做一些优化，具体是指如果1个函数是进行递归调用，则只生成1个栈帧。

这种优化策略能够极大的减少内存空间的占用，也被称之为尾递归优化。

遗憾的是，Python并未实现尾递归优化。